<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <title>Jeff Lindsay, Open source hacker</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/blog/atom.xml" />
    <link rel="shortcut icon" type="image/x-icon" href="/images/JeffLindsayDeluxe.png" />
    <link href='https://fonts.googleapis.com/css?family=Dosis:400,300,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Roboto:400,300,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Condensed:400,300,700|Lora:400,700,400italic|Vollkorn:400,700' rel='stylesheet' type='text/css'>
    <link href="/stylesheets/all.css" rel="stylesheet" />
    
  </head>
  <body>
  <div id="wrapper">

    <header>
  <div class="container">
  <div class="row">
      <div class="col-lg-8 col-lg-offset-1">
        You're reading the <a href="/blog">blog</a> of Jeff Lindsay (<a href="http://twitter.com/progrium">@progrium</a>). There is also his <a href="/wiki">wiki</a>.
      </div>
  </div>
</div>
</header>

<main id="main" role="main">
  <section>
<div class="container">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-1">
          <article>
            <div class="meta">
                <div class="date">
                    <span class="month">Oct</span>
                    <span class="day">05</span>
                    <span class="year">2015</span>
                </div>
            </div>
            <h1><a href="/blog/2015/10/05/the-next-10-years-megalith/">The Next 10 Years: Megalith</a></h1>
            <p>I've decided what I'm going to be working on for the next 10 years. It's epic and exciting, and I'm going to need your help. It's called Megalith.</p>

<p>Megalith is a symbol of the ideal I've been working towards my entire career. It's constantly evolving and very nuanced. I'm going to be upfront and say that I'm not going to be able to fully explain what Megalith is in this post. Instead, I'm going to start setting up context. To me, context is everything.</p>

<p>For the past few years I've been spending most of my working hours writing open source software related to a project I worked on in 2012 called <a href="http://docker.com">Docker</a>. Docker was created as a skunkworks collaboration between me and some talented engineers at dotCloud, now Docker. The company pivoted 100% to Docker and is now worth about a billion dollars. As an independent, I didn't stay with Docker, I moved on to the next problem. Docker was one piece of a grander vision.</p>

<p>To help pay for this lifestyle, I've experimented with sponsorships and even fell into lucky situations. Last year I tried to make it a little more sustainable by starting <a href="http://gliderlabs.com">Glider Labs</a> with a friend. We focused on consulting around Docker. We helped some of the first people to actually run Docker in production. We did this to learn and get a better grasp on the Real Problems. Something many vendors in this space don't really do. We learned a lot and as a result we ended up making a lot more open source software.</p>

<p>The problem is that there is a lot more to make. This ideal I have in mind that's been developing in my head for over 5 years is a massive undertaking. I've realized if I'm going to keep pursuing it, I need two things: a better vehicle for the work, and a unifying project to get help around it.</p>

<h2 id="building-a-better-organization-for-this-work">Building a better organization for this work</h2>

<p>The software I write that people love comes from a compulsive drive that goes beyond and even against the idea of startups. With the exception of Docker and a few other collaborations, I've never made anything that people loved while working for a startup. Naming and evangelizing webhooks was not something anybody paid me to do. In fact, a lot of projects I've built or think should exist are too small to sustain a startup. Does that mean they shouldn't be built? Or that I should temporarily dedicate my life to maybe make one of them work as a startup?</p>

<p>Even a lifestyle business is quite a commitment to make work. My friend <a href="https://inconshreveable.com/">Alan Shreve</a> made <a href="https://ngrok.com/">Ngrok</a>, inspired by my tool <a href="https://github.com/progrium/localtunnel">Localtunnel</a>. It's free and open source, but he's also bootstrapped a business out of it. This business is what he spends most his working hours on.</p>

<p>Given my goals and values I do prefer this approach, but it still poses a problem. The time spent writing lines of code to support a business, the time spent figuring out market fit, the time spent on support and operations … this is time not moving forward to me. It's extracting wealth out of something that already exists.</p>

<p>Why do this? So Alan can sustain himself and potentially fund other projects, right? In the meantime, I know for a fact that there's a lot of great open source software that he's not making.</p>

<p>His goal is passive income. For a lot of us independents, that's the dream. It may or may not realize in full, but it's certainly time consuming either way. In that way, it's sort of just a smaller variation of the startup lottery.</p>

<p>Meanwhile, in the same time, I've put out dozens of open source projects that solve problems or work towards dissolving larger problems in the long-term. I actually can't help it. It's compulsive like I said. The only way I see it stopping is if I leave the space altogether. I don't get paid to do 90% of these projects. They help bring me contract work, but seemingly only to take time away from supporting and building a community around those projects.</p>

<p>The other problem, for me, is that running a business causes you to make software differently. You think about building software you can sell, or that supports what you can sell. More than doing one thing well, you think about the features people will pay for. More than making it simple, you think about obscure enterprise and legacy use cases. Conventional knowledge says you must do those in some way at some point because that's How It Works.</p>

<p>The problem is worse for startups that take VC money. Even VCs that "get it" and let you focus on open source traction still expect you to eventually figure out how to monetize and make them millions. To varying degrees this often makes startups:</p>

<ul>
  <li>focus on enterprise customers, not regular developers</li>
  <li>ship software that solves short-term problems, or yesterday's problems</li>
  <li>prioritize sexy demoware without production hardening</li>
  <li>increase perceived value with more hires and more partnerships</li>
  <li>de-prioritize any effort outside the product that makes money</li>
</ul>

<p><a href="https://hashicorp.com/">Hashicorp</a> is one of the best examples of companies in this space that have done a good job at taking just enough VC and working against a lot of these forces. However, they still work within the framework. They still have a commitment to exit big someday. The implications of this are not insignificant.</p>

<p>I'm much more likely to bootstrap a company like Alan than take VC money. Not only is it just more my style, but a VC startup just won't play to my strengths. Though, building a bootstrap business doesn't seem to produce the most value for my time either. Or make me very happy.</p>

<p>I'd much rather find a new way. Not just because I want to play to my strengths, but because I know I'm not the only one this applies to. I also know that a different, better kind of open source software will result if done properly.</p>

<p>What I want is something of an independent R&amp;D lab. I want us to <a href="http://gliderlabs.com/blog/2015/04/08/what-have-we-been-doing-for-40-years/">re-capture</a> the innovation and <em>invention</em> of Xerox PARC and Bell Labs, but focusing on open source. I want us to have the freedom to explore and build software <em>right</em> with like-minded people. Not to get rich, but to <em>slow cook software</em>. Systems software that further empowers individuals and small groups … enterprise customers of the future, not the past.</p>

<p>This is what I want Glider Labs to transition into. In fact, it's already been operating like this in a way. And I've been exploring and learning ways to make this work for years now. It's part business, part cooperative, part public service. But to make the leap to a lab that supports more than myself, it won't happen over night. And I can't do it by myself.</p>

<h2 id="sharing-the-vision-enabling-participation">Sharing the vision, enabling participation</h2>

<p>This isn't just about a new organization. It has to have some purpose, some initial unifying project. In order to start from nothing, there needs to be a clear mission of value. Not just boundless experimentation. Luckily, most of my work does fall under a certain theme driven by a nebulous but nonetheless motivating ideal. That seems like a good place to start.</p>

<p>I've been told if I just wrote down everything I want to build and why, people might be willing to help out. This is challenging both because of scope and its constant evolution. I figured if I just keep making projects people will start to see it, but other than a few people I'm not sure that's working out. So I'm going to try a more top-down approach.</p>

<p>The real project this post is about is a meta-project I'm calling Megalith. It's an umbrella project to help unify and bring a common goal to all the work I've been doing for the past 10 years, and over the next 10 years.</p>

<p>I know I can't do it alone, so the project is designed for participation. It will involve many more specific projects that are open source and independently useful. Many already exist. Most do not.</p>

<p>Whether or not the final ideal is achieved, it will be approached. Lots of value will be produced in the process. Not just software and contributions to existing open source, but guides and how-to knowledge of everything I've learned to lead me to my current conclusions, and everything we learn in the process.</p>

<p>Glider Labs and Megalith are separate but related parts of this venture. Megalith is the meta-project, Glider Labs is the organization. The idea is that they support each other. Megalith makes this new Glider Labs a reality, Glider Labs makes Megalith a reality.</p>

<h2 id="relevant-to-your-interests">Relevant to your interests?</h2>

<p>The first step is to explain Megalith and try to communicate this idea in my head, or at least some manifestation of it. Then everything else will start to make sense. It's almost more about approach and values. It's about an idea of simple, composable, extensible tools to make modern end-to-end development and operations sane at both large and small scale. And making the world more programmable…</p>

<p>Anyway, it's more than I can get into here. I've set up <a href="http://eepurl.com/bAietL">an announcement mailing list</a> you can subscribe to. Sign up and you'll get emails about what's next. I might even email you directly to say hi.</p>

<p>Feel free to get in touch with me, leave a comment below, or help out by sharing this post if it resonates with you. I'm pretty excited, especially since a lot of people have expressed interest so far.</p>

<p>Lastly, here's a silly video I made about it:</p>

<center><iframe src="https://player.vimeo.com/video/140272143" width="600" height="337" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe></center>

<p><br />
<strong><a href="http://eepurl.com/bAietL">Subscribe for updates!</a></strong></p>

          </article>
          <a href="/blog/2015/10/05/the-next-10-years-megalith/#disqus_thread">Comments</a>
          <br /><br />
        </div>

        <div class="col-lg-3" id="sidebar">
    <img src="https://dl.dropboxusercontent.com/u/2096290/Blog/progrium2016.png" id="photo" title="Jeff Lindsay" />
    <p>
        Jeff Lindsay is a design-minded software programmer living in Austin, Texas. 
    </p>
    <p>
        He founded <a href="http://gliderlabs.com">Glider Labs</a>, an open source innovation lab.
        There he writes <a href="http://gliderlabs.com/projects">open source developer infrastructure</a> 
        to make the world more programmable.
    </p>
    <p><a href="/wiki/InfluenceAndAffiliations/">Learn more about Jeff.</a></p>
    <h5>
      <a rel="me" href="https://twitter.com/progrium"><i class="fa fa-twitter-square fa-2x"></i></a>
      <a rel="me" href="https://github.com/progrium"><i class="fa fa-github fa-2x"></i></a>
      <a ref="me" href="https://instagram.com/progrium"><i class="fa fa-instagram fa-2x"></i></a>
      <a ref="me" href="https://vimeo.com/progrium"><i class="fa fa-vimeo-square fa-2x"></i></a>
    </h5>
</div>

    </div>
</div>
</section>

<section class="subscribe" style="padding: 20px 0;">
  <div class="row">
  <div class="col-lg-8 col-lg-offset-1">
    <i class="fa fa-envelope"></i>
    <a href="http://eepurl.com/bUo8Rb">Subscribe</a> to get future blog posts sent to you via email.
  </div>
  </div>
</section>


<section  class="alternate">
<div class="container">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-1">
          <article>
            <div class="meta">
                <div class="date">
                    <span class="month">Oct</span>
                    <span class="day">28</span>
                    <span class="year">2014</span>
                </div>
            </div>
            <h1><a href="/blog/2014/10/28/deis-breathes-new-life-into-dokku/">Deis Breathes New Life into Dokku</a></h1>
            <p>Today I'm excited to announce that <a href="https://github.com/progrium/dokku">Dokku</a> is now sponsored by my friends of the <a href="http://deis.io/">Deis</a> project. This means that <a href="http://opdemand.com/">OpDemand</a>, the company behind Deis, will be funding part-time development of Dokku and its components.</p>

<h2 id="remember-dokku">Remember Dokku?</h2>

<p>A little over a year ago, <a href="http://progrium.com/blog/2013/06/19/dokku-the-smallest-paas-implementation-youve-ever-seen/">I announced Dokku</a> as an open source "Docker powered mini-Heroku." It quickly became the first killer application for Docker. Designed to be simple and hackable, Dokku enables web developers to run their own single-host PaaS that's directly compatible with Heroku.</p>

<p>As the project took off, I went on to tackle the challenges of a multi-host PaaS with the <a href="https://flynn.io/">Flynn</a> team. Even without me, the Dokku community continued to grow, thanks to the help of new maintainers and contributors. The experimental plugin system allowed all sorts of customizations and extensions of Dokku to flourish.</p>

<p>Over time, though, the wonderful volunteer maintainers of the project started to get burnt out. Handling issues across a dozen language runtimes and even more plugins is taxing. Many were upstream buildpack or Docker issues, or larger inherent problems of the project requiring stronger leadership to resolve.</p>

<p>Although Dokku is still used and loved today, without active maintainership and leadership, it was at risk of "bit rot". I came to the conclusion that it was in need of some love from the original author. Luckily, the Deis team was willing to help make this happen and is effectively saving the project from a slow death.</p>

<h2 id="about-deis">About Deis</h2>

<p>Not long after I started collaborating with the Flynn team, another project called Deis came onto the scene. Both projects have the goal of being enterprise grade, multi-host PaaS solutions. Although technically competitive, as open source projects composed of great people, we openly share information and components. As an independent agent, I try to bridge silos and facilitate that kind of sharing and communication. I'd gone out to visit both teams to collaborate, talk shop, and have fun.</p>

<p>I eventually moved on from Flynn and started independently exploring distributed systems components in a Docker world. Deis continued to adopt and support many of my open source components. They always kept an open dialog with me and others in the Docker community. When I mentioned my plans to reinvigorate Dokku, they were quick to offer help.</p>

<h2 id="the-sponsorship">The Sponsorship</h2>

<p>The timing for this sponsorship is perfect. Deis now requires at least 3 hosts in a cluster, making Dokku the obvious recommendation for smaller deployments. The projects will focus on shared components even more. This sponsorship will also ensure a smooth migration to Deis if a Dokku user wants to go down that path.</p>

<p>What is Dokku expected to get? First, time and thought put into getting the project modernized and on path for a solid 1.0 release. Among other things, this involves redesigning aspects of the project to make it more sustainable as an open source project.</p>

<p>Much of the lessons of Flynn and Deis, as well as reflections on Dokku itself, will feed back into Dokku. My plan is to:</p>

<ul>
  <li>make it more robust and testable</li>
  <li>improve code quality and standards</li>
  <li>properly direct upstream issues upstream</li>
  <li>improve documentation and basic support processes</li>
  <li>add popular features, such as addons and Dockerfile build support</li>
</ul>

<p>And if you can believe it, I plan to make it more modular and even simpler.</p>

<h2 id="yay-dokku">Yay, Dokku!</h2>

<p>Along with Deis, I want to thank all the <a href="https://github.com/progrium/dokku/graphs/contributors">contributors</a> and maintainers involved in Dokku. I especially want to thank asm89, rhy-jot, plieter, fcoury, and josegonzalez. The project would already be dead without them. If you want to get involved, I'll generally be in the <code>#dokku</code> channel on Freenode sharing updates as I progress. Most of my work will be in a new branch, but first it will take place in creating and updating components used by Dokku.</p>

<p>I'm only able to put a day or so of hours a week into the project, but steady, consistent effort and help from the community will ensure Dokku will be around for a long time!</p>


          </article>
          <a href="/blog/2014/10/28/deis-breathes-new-life-into-dokku/#disqus_thread">Comments</a>
        </div>
    </div>
</div>
</section>
<section >
<div class="container">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-1">
          <article>
            <div class="meta">
                <div class="date">
                    <span class="month">Sep</span>
                    <span class="day">10</span>
                    <span class="year">2014</span>
                </div>
            </div>
            <h1><a href="/blog/2014/09/10/automatic-docker-service-announcement-with-registrator/">Automatic Docker Service Announcement with Registrator</a></h1>
            <p>No matter which service discovery system you use, it will not likely know how to register your services for you. Service discovery requires your services to somehow announce themselves to the service directory. This is not as trivial as it sounds. There are many approaches to do this, each with their own pros and cons.</p>

<p>In an ideal world, you wouldn't have to do anything special. With Docker, we can actually arrange this with a component I've made called <a href="https://github.com/progrium/registrator">Registrator</a>.</p>

<p>Before I get to Registrator, let's understand what it means to register a service and see what kind of approaches are out there for registering or announcing services. It might also be a good idea to see my last posts <a href="http://progrium.com/blog/2014/08/20/consul-service-discovery-with-docker/">on Consul</a> and <a href="http://progrium.com/blog/2014/07/29/understanding-modern-service-discovery-with-docker/">on service discovery</a> in general.</p>

<h2 id="service-registration-data-model">Service Registration Data Model</h2>

<p>Service registration involves a few different pieces of information that describes a service. At the very least, it will involve a service name, such as "web", and a locating IP and port. Often, there is a unique ID for a service instance ("web.2"). Some systems generate this automatically.</p>

<p>Around this, there might be extra information or metadata associated with a service. In some systems this could be key-value attributes. Or maybe just tags. Classic service discovery of the zero-configuration world would also include the protocol (HTTP, SMTP, Jabber, etc), but this isn't very useful information since in our case we already know the protocol of the service we're looking for.</p>

<p>When using etcd or Zookeeper it's up to you how your service directory works, both what information is stored and how to structure it. Specialized service discovery systems like Flynn's discoverd or Netflix's Eureka provide more structure around service semantics. Consul is sort of a hybrid, since it's really a specialized service discovery system built-in to a general configuration store.</p>

<p>Consul lets you define a service name, IP, port, optional service ID, and optional tags. In a future release, I believe it will tie in more with the key-value store to allow you to have arbitrary attributes associated with a service. Right now, Consul also lets you define a health check to use with its monitoring system, which is unique to Consul.</p>

<p>So far, that gives you an idea of the data involved in registering a single service, but that's not the complete model. A service "record" is a reference to an actual service, and it's important to understand what that actually is. Whether using containers or not, a service will always boil down to a long-running process, and a process may listen on several ports. This could imply multiple services.</p>

<p>One could argue that if a process listens on multiple ports for the same functional service, it might be a good idea to collapse it into a single service. Modeling it in this way ends up being either complicated (putting the other service ports in meta-data), or incomplete ("which port do I use for TLS?"). I've found it's simplest to just model each port a process listens on as a separate service, using the name to logically group them. For example, "webapp-http" and "webapp-https".</p>

<h2 id="registering-in-process-or-using-a-coprocess">Registering In-process or Using a Coprocess</h2>

<p>The most common strategy to register in service discovery is actually directly self-registering from the service process itself. From a "good solution" perspective, this might seem terrible. But it's common for a reason. Mostly, it's pragmatic, as many organizations build their specific services around their specific service discovery system. However, it does have other advantages.</p>

<p>Service discovery systems like Eureka and discoverd provide a library that can be used in your service to register itself, as well as lookup and discover other services from in-process. This provides opportunities like having balancing and connection pooling logic taken care of for you, without the extra hop of a reverse proxy. And in cases where heartbeats are used for liveness, the library can handle heartbeating for you.</p>

<p>The disadvantage of this approach as a reusable system is that libraries are hard provide across languages, so there might be limited language support for the library. Depending on how complex the library is, it may also be difficult to port for people that want to make the effort to expand language support.</p>

<p>Though, the biggest disadvantage is putting the responsibility on the service in the first place. This creates two problems. First, if you intend to make your services useful to anybody else, your service will be less portable across environments that use different discovery mechanisms. Netflix open source projects suffer from this, as people already complain it's too hard to use some of their components without using all of them. Second, third-party components and services like Nginx, Memcached, or pretty much any datastore will not register themselves.</p>

<p>While some software might provide hooks or extensions to integrate with your service discovery, this is pretty rare. And patching is not a scalable solution. Instead, the common solution for third-party services is to put the registering responsibility <em>near</em> the service.</p>

<p>If you're not directly registering in-process, the second most common approach is running another parallel process to register the service. This works best with a process manager like systemd that can ensure if the service starts, so does the paired registering service.</p>

<p>Some call this technique using a coprocess or a "sidekick". When working with containers, I usually use coprocess in reference to another process in the same container. A sidekick would be a separate container and process. Either way, this is a useful pattern even beyond service registration. I use it for other administrative services that support the main service, for example to re-configure the service. The open source PaaS Deis used this pattern for shipping out a service's logs. However, it seems to simplify they're <a href="https://github.com/deis/deis/issues/1714">moving to my tool logspout</a>.</p>

<p>A variation of using a coprocess is process "wrapping", where you use a launcher process that will register and run the service as a child process. Flynn does this with sdutil. Some might say it can make starting services feel very complicated since you now have to configure the service as usual, on top of providing registration details to the launcher. At the end of the day, this is effectively the coprocess model launched with one command instead of two.</p>

<h2 id="the-problem-with-a-coprocess-for-registering">The Problem with a Coprocess for Registering</h2>

<p>In whatever form it comes, a coprocess comes with two challenges: configuration and manageability.</p>

<p>With a parallel announcing process, you need to tell it what service or services it should announce, providing it all the information we talked about before. An interesting problem with any external registration solution is where that service description is stored. For example, if you were doing announcement in-process, it would at least already know what ports it exposes. However, it most likely wouldn't know what the operator wants to call it. Some systems will roll all this information up into higher-level system constructs, like "service groups" or some unit of orchestration. I prefer not to couple service discovery with orchestration. Instead, I'd rather service semantics live as close to the service process as possible.</p>

<p>A coprocess or sidekick for registering also means you'll have one for every service you start. There is no technical problem with this, but it introduces operational complexity. A system has to manage this, whether it's a process manager like systemd or full-on orchestration. That system likely has to be configured, adding more configuration, which may or may not be the right place to define the service. And now you need to be sure to always use this system to launch any service, since running a service by hand will not register the service.</p>

<p>In an ideal world, we don't worry about any of this. We just run a service and its ports somehow get registered as services. If we want to specify more details about the service, we can do this in a way that's packaged as close to the service as possible. And of course, we want an operator and automation friendly way to set or override that service definition at runtime.</p>

<h2 id="how-docker-helps-achieve-the-ideal">How Docker Helps Achieve the Ideal</h2>

<p>Running services in Docker provides a number of benefits, and those who believe Docker is just about container isolation clearly miss the point. Docker defines a standard unit of software that can have anything in it and yet have a standard interface of operations. This interface works with a runtime that gives you certain capabilities in managing and operating that unit of software. These capabilities and this common container model happen to have everything we need to automatically register services for any software.</p>

<p>The Docker container image includes default environment variables, which can be defined by the Dockerfile. This turns out to be the perfect place to describe the service it contains. The container author has the option to use the environment variables to include their idea of how the service should be described and registered, which will be shipped with the container wherever it goes. The operator can then set runtime environment variables to further define or redefine their own description of the service.</p>

<p>The Docker runtime makes these values easy to inspect programmatically. The runtime also produces events when a container starts or stops, which is generally when you want to register or deregister the services of the container.</p>

<p>All this together lets us provide automatic service registration for any Docker container using a little appliance I've made called Registrator.</p>

<h2 id="introducing-registrator">Introducing Registrator</h2>

<p>Registrator is a single, host-level service you run as a Docker container. It watches for new containers, inspects them for service information, and registers them with a service registry. It also deregisters them when the container dies. It has a pluggable registry system, meaning it can work with a number of service discovery systems. Currently it supports Consul and etcd.</p>

<p>There are a few neat properties of Registrator:</p>

<p>First, it's automatic. You don't have to do anything special other than have Registrator running and attached to a service registry. Any public port published is registered as a service.</p>

<p>Related but fairly significant, it requires no cooperation from inside the container to register services. If no service description is included and the operator doesn't specify any at runtime, it uses Docker container introspection for good defaults.</p>

<p>Next, it uses environment variables as generic metadata to define the services. Some people have asked how you can add metadata to Docker containers, but the answer is right in front of them. As mentioned this comes with the benefit of being able to define them during container authorship, as well as at runtime.</p>

<p>Lastly, the metadata Registrator uses could become a common interface for automatic service registration beyond Registrator and even beyond Docker. Environment variables are a portable metadata system and Registrator defines a very data-driven way to define services. That same data could be used by any other system.</p>

<p>In terms of previous work, Michael Crosby's project <a href="https://github.com/crosbymichael/skydock">Skydock</a> was a big inspiration on the direction of Registrator, so it might be worth looking into for reference. Registrator is a little more generic and made specifically for distributed systems, not as much for single host registries. For example, Registrator focuses on published ports and uses a host-level IP as opposed to local container IPs. For people interested in single-host discovery, Registrator has already inspired compatible alternatives, including Brian Lalor's <a href="https://github.com/blalor/docker-hosts">docker-hosts</a>.</p>

<p>In any case, I believe I've made the first general purpose solution to automatic service registration. Here's a video demo:</p>

<p style="text-align: center;"><iframe src="//player.vimeo.com/video/105806672" width="640" height="360" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe></p>

<h2 id="onward">Onward…</h2>

<p>In retrospect, the problem we've solved here now seems very trivial, but we've never had this before. Like many good designs, it can take a while for all the pieces to come together and make sense in one's mind before it becomes obvious. Once it's obvious, it seems like it always was.</p>

<p>Combining auto-registration with a good service directory, you're almost to an ideal service discovery system. That last problem is about the other side of discovery: connecting to registered services. The next post will describe how this is also not as trivial as it sounds, and as usual, I will offer an open source solution.</p>

          </article>
          <a href="/blog/2014/09/10/automatic-docker-service-announcement-with-registrator/#disqus_thread">Comments</a>
        </div>
    </div>
</div>
</section>


<section class="alternate">
<div class="container">
    <div class="row">
        <div class="col-lg-12">
        <ul class="pager article">
          <li class="previous">
            <a href="/blog/page3/">&larr; Older</a>
          </li>

          <li class="next">
            <a href="/blog/">Newer &rarr;</a>
          </li>
        </ul>
        </div>
    </div>
</div>
</section>

</main>



    <footer>
      <div class="container clearfix">
        &copy; 2016 Jeff Lindsay
      </div>
    </footer>

  </div>
  <script src="/javascripts/all.js"></script>
  <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script>
        <script type="text/javascript">
        try {
        var pageTracker = _gat._getTracker("UA-6824126-1");
        pageTracker._trackPageview();
        } catch(err) {}</script>
    <!--script type="text/javascript">
      var host = "progrium.com";
      if ((host == window.location.host) && (window.location.protocol != "https:"))
        window.location.protocol = "https";
    </script-->
    <script type="text/javascript">
      
    </script>
  </body>
</html>
